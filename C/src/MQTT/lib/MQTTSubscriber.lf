/**
 * Reactor that subscribes to a specified MQTT topic on which
 * string messages are published.
 * See MQTTPhysical and MQTTLogical for prerequisites and an example usage.
 * This uses the Paho MQTT Client Library, documented here:
 *    https://www.eclipse.org/paho/files/mqttdoc/MQTTClient/html/_m_q_t_t_client_8h.html
 * The client library itself may be found here:
 *    https://github.com/eclipse/paho.mqtt.c
 * 
 * @author Ravi Akella
 * @author Edward A. Lee
 */
target C

/**
 * Reactor that subscribes to a specified MQTT topic on which
 * string messages are published. The timestamp of the output
 * will depend on the use_physical_time parameter.
 * 
 * If use_physical_time is false (the default), then this reactor
 * extracts the publisher's timestamp from the message and adds the
 * specified offset to get the desired output timestamp. 
 * 
 * If use_physical_time is true, then this reactor ignores the
 * publisher's timestamp and uses the current physical time plus the
 * offset as the desired output timestamp. If the offset is zero, this
 * transport latency. With this setting, this timestamp increment
 * also measures the apparent communication latency.
 * 
 * In both cases, if the desired output timestamp is in the past
 * when the message arrives, then a warning will be printed and
 * the tag of the message will be one microstep later than
 * the current tag when it arrives.
 * 
 * At shutdown, this reactor reports the apparent latency, which is
 * the physical time of arrival of the message minus the timestamp
 * carried by the message. If clocks are perfectly synchronized at
 * the publisher and subscriber, then this is a measure of the
 * communication latency.
 * 
 * Note that the communication from a publisher to a subscriber
 * behaves roughly like a logical connection if use_physical_time is
 * false and like a physical connection if use_physical_time is true.
 * The offset is roughly equivalent to an after delay. There are some
 * subtle distinctions, however. One is that logical time can advance
 * between when the publisher launches a message, sending it to the
 * MQTT broker, and when the subscriber receives it. This may make
 * it impossible to match the desired timestamp and will result in
 * warning messages being printed. A second distinction is that
 * even when desired timestamps are met most of the time, a message
 * that is launched at the timeout time will never be received
 * even if, had it been received, it would have been given the
 * same timestamp at the timeout time.
 * 
 * @param address The IP address of the MQTT broker.
 * @param clientID The name of the client instance.
 *  These names are required to be unique.
 * @param topic The topic name to which to subscribe.
 * @param use_physical_time If true, then use physical time.
 * @param offset The offset to add to the publisher's timestamp.
 * @see MQTTPublisher.
 */
reactor MQTTSubscriber (
    address:string("tcp://localhost:1883"),
    clientID:string("DefaultSubscriber"),
    topic:string("DefaultTopic"),
    use_physical_time:bool(false),
    offset:time(0)
) {
    preamble {=
        #include "MQTTClient.h"
        #include "core/federated/net_util.h"
        
        // Fix the QoS to indicate that the message will be delivered reliably exactly once.
        #define QOS         2
        
        typedef struct MQTTSubscriber_info_t {
            void* logical_action;
            interval_t offset;
            bool use_physical_time;
            interval_t latencies;     // Sum of all observed latencies.
            interval_t max_latency;
            size_t count;
        } MQTTSubscriber_info_t;
        
        // Connection options for the client.
        // Making this global means that all instances of this reactor have
        // the same connection options.
        MQTTClient_connectOptions sub_connect_options = MQTTClient_connectOptions_initializer;
                
        // Callback function invoked by MQTT when a message arrives.
        int message_arrived(
            void *info,
            char *topic_name,
            int topic_length, // If 0, strlen(topic_name) can be trusted.
            MQTTClient_message *message
        ) {
            // FIXME: This is assuming that the message string
            // and topic_name are null terminated. What if they aren't?
            // Perhaps force them to be?
            LF_PRINT_LOG(
                "MQTTSubscriber: Message arrived on topic %s: %s", topic_name, (char*)message->payload
            );
            
            MQTTSubscriber_info_t* my_info = (MQTTSubscriber_info_t*)info;
            
            my_info->count++;
                     
            // Enter a critical section so that logical time does not elapse while
            // we calculate the delay to the logical time for the message.
            lf_critical_section_enter();
            
            interval_t delay;
            instant_t current_time = lf_time_logical();
            interval_t offset = my_info->offset;
            
            // Extract the publisher's timestamp from the message.
            instant_t timestamp = extract_int64(
                (unsigned char*)message->payload + message->payloadlen - sizeof(instant_t)
            );
            instant_t physical_time = lf_time_physical();
            
            interval_t latency = physical_time - timestamp;
            my_info->latencies += latency;
        
            if (latency > my_info->max_latency) {
                my_info->max_latency = latency;
            }
            
            if (my_info->use_physical_time) {
                // Use physical time.
                delay = physical_time + offset - current_time;
            } else {
                // Use logical time.
                delay = timestamp + offset - current_time;
            }
            LF_PRINT_LOG(
                "MQTTSubscriber: Received message. Timestamp will be " PRINTF_TIME
                " ahead of current (elapsed) time, " PRINTF_TIME, delay, current_time - start_time
            );
                        
            // Schedule the event.
            // We rely on lf_schedule_copy to issue a warning if the delay is negative.
            lf_schedule_copy(
                ((MQTTSubscriber_info_t*)info)->logical_action,
                delay,
                (char*)message->payload,
                message->payloadlen - sizeof(instant_t)
            );
            
            lf_critical_section_exit();

            // MQTTClient_freeMessage() also frees the memory allocated to the payload,
            // which is why we have to copy the message here.
            MQTTClient_freeMessage(&message);
            MQTTClient_free(topic_name);
            
            // Return true to indicate that the message has been successfully handled.
            return 1;
        }
        
        /** Callback invoked if the connection is lost. */
        void sub_connection_lost(void *info, char *cause) {
            lf_print_warning("MQTTSubscriber: Connection lost. Cause: %s", cause);
        }
    =}
    
    /**
     * Output for sending the incoming MQTT message.
     * Use type char* rather than string because it is not
     * a static string, but rather dynamically allocated memory.
     */
    output message:char*;

    /**
     * Action that is triggered when there is an incoming MQTT message.
     * Use a logical action here so that the callback function can
     * precisely control timestamp of the received message.
     */
    logical action act:char*;
    
    /** State variable storing the MQTT client created for each instance of this reactor. */
    state client:MQTTClient({=NULL=});
        
    /** Struct containing the action and offset. */
    state info:MQTTSubscriber_info_t({= {NULL, 0LL, false, 0LL, 0LL, 0} =})
    
    reaction(startup) -> act {=
        int rc; // response code.

        // In case there are multiple instances of this or the subscriber, enter
        // a critical section. The Paho MQTT functions are not thread safe.
        lf_critical_section_enter();

        rc = MQTTClient_create(
            &self->client, self->address, self->clientID, MQTTCLIENT_PERSISTENCE_NONE, NULL
        );
        if (rc != MQTTCLIENT_SUCCESS) {
            lf_print_error_and_exit("MQTTSubscriber: Failed to create MQTT client.\n"
                    "Return code: %d\n", rc);
        }

        sub_connect_options.keepAliveInterval = 20;
        sub_connect_options.cleansession = 1;
        
        self->info.logical_action = act;
        self->info.offset = self->offset;
        self->info.use_physical_time = self->use_physical_time;
        
        // Set up callback functions.
        // Last argument should be a pointer to a function to
        // handle notification of delivery of a sent message.
        // But this reactor isn't sending any messages.
        MQTTClient_setCallbacks(self->client, &self->info, sub_connection_lost, message_arrived, NULL);
        
        // Connect to the broker.
        rc = MQTTClient_connect(self->client, &sub_connect_options);
        if (rc != MQTTCLIENT_SUCCESS) {
            lf_print_error_and_exit(
                    "MQTTSubscriber: Failed to connect to MQTT broker.\n"
                    "Perhaps one is not running? Return code: %d\n", rc);
        }
        
        MQTTClient_subscribe(self->client, self->topic, QOS);
        
        lf_critical_section_exit();
    =}
    
    reaction(act) -> message {=
        // The action contains a token that we can just forward.
        // The allocated memory will be freed when the token's reference count hits 0.
        // Note that this token will still contain the publisher's timestamp.
        lf_set_token(message, act->token);
    =}
    
    reaction(shutdown) {=
        lf_print(
            "MQTTSubscriber: Maximum apparent latency measured at receiver (in nsec): " PRINTF_TIME,
            self->info.max_latency
        );
        if (self->info.count > 0) {
            lf_print(
                "MQTTSubscriber: Average apparent latency measured at receiver (in nsec): " PRINTF_TIME,
                self->info.latencies/self->info.count
            );
        }
        LF_PRINT_LOG("MQTTSubscriber: Client ID %s disconnecting.", self->clientID);
        MQTTClient_disconnect(self->client, 10000);
        MQTTClient_destroy(&self->client);
    =}
}
