/**
 * A basic user interface realized in the browser.
 * This creates a basic web server that listens on a port (default 8080)
 * for requests. When it receives a request with no path
 * (e.g. "http://localhost:8080/"), it responds with the contents
 * of a file specified by the `initial_file` parameter, which is expected
 * to be an HTML file.
 * 
 * When it receives a request with a path (e.g. "http://localhost:8080/test"),
 * it responds with text. Normally, this would be JSON-formatted, but in this
 * simple illustration, it is just plain text that reports the count of the
 * number of requests that have been received.
 * 
 * The default `initial_file` provides HTML containing a button that the user
 * can push to issue a request with a path. This results in a display in the
 * web page of the number of times the button has been pushed.
 * 
 * @author Edward A. Lee
 */
target C {
    keepalive: true
}
import FileReader from "../lib/FileReader.lf"
preamble {=
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <unistd.h>     // Defines read()
    #include <libgen.h>     // Defines dirname()
    
    #include "util.h"       // Defines lf_print() FIXME: Should not be necessary.
    #include "platform.h"   // Defines lf_thread_t, etc. FIXME: Should not be necessary.
    
    #if _WIN32 || WIN32
    #define FILE_PATH_SEPARATOR '\\'
    #else
    #define FILE_PATH_SEPARATOR '/'
    #endif
    
    typedef struct browser_ui_t {
        bool running;       // Indicator that listener thread is running.
        int client_socket;  // If non-negative, client socket awaiting response.
        void* req_action;   // The physical action triggered upon request.
        uint16_t hostport;  // The port to use for HTTP access.
        char* initial_page; // Initial web page contents.
    } browser_ui_t;
        
    const char html_header[] =  "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n\r\n";
    
    void* listener_thread(void* args) {
        browser_ui_t* browser_ui = (browser_ui_t*)args;
        
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket < 0) {
            lf_print_error_and_exit("Error creating socket.");
        }

        int one = 1;
        // Allow reusing of local addresses.
        setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(int));

        struct sockaddr_in server_address;
        server_address.sin_family = AF_INET;
        server_address.sin_addr.s_addr = INADDR_ANY;
        server_address.sin_port = htons(browser_ui->hostport);

        if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {
            close(server_socket);
            lf_print_error_and_exit("Error binding socket.");
        }
        // Pending queue length of 5.
        listen(server_socket, 5);
        
        lf_print("****** Point your browser to http://localhost:%d", browser_ui->hostport);

        while(browser_ui->running) {
            struct sockaddr_in client_address;
            int client_address_length = sizeof(client_address);
    
            browser_ui->client_socket = accept(server_socket, (struct sockaddr *)&client_address, (socklen_t*)&client_address_length);
    
            if (browser_ui->client_socket < 0) {
                lf_print_error_and_exit("Error accepting connection.");
            }

            char buffer[1024] = {0};
            read(browser_ui->client_socket, buffer, 1024);
    
            // The response depends on the path part of the request.
            const char *start_of_path = strchr(buffer, ' ') + 1;
            if (start_of_path != NULL && strncmp("/ ", start_of_path, 2) != 0) {
                const char *end_of_path = strchr(start_of_path, ' ') + 1;
                size_t length = end_of_path - start_of_path;
                char* path = (char*)malloc(length + 1);
                strncpy(path, start_of_path, length);
                path[length] = '\0';
                lf_schedule_value(browser_ui->req_action, 0, path, length + 1);
            } else {
                // Default is to write initial page.
                write(browser_ui->client_socket, html_header, strlen(html_header));
                write(
                    browser_ui->client_socket,
                    browser_ui->initial_page,
                    strlen(browser_ui->initial_page)
                );
                close(browser_ui->client_socket);
                browser_ui->client_socket = -1;
            }
        }
        return NULL;
    }
=}

/**
 * @param initial_file Path to the initial HTML file to serve, relative to the source directory.
 *  Defaults to "page.html".
 * @param hostport The host port number, which defults to 8080.
 */
reactor ServerUI(
    initial_file:string = "page.html",
    hostport:uint16_t = 8080
) extends FileReader {
    output request:char*
    input response:char*
    
    physical action req_action:char*
    
    state browser_ui:browser_ui_t
        
    reaction(startup) -> req_action {=
        // Read the default file to serve.
        self->browser_ui.initial_page = read_file(self->initial_file);
        
        self->browser_ui.running = true;
        self->browser_ui.client_socket = -1; // No client socket awaiting response.
        self->browser_ui.req_action = req_action;
        self->browser_ui.hostport = self->hostport;
        
        lf_thread_t listener;
        lf_thread_create(&listener, &listener_thread, &self->browser_ui);
    =}
    
    reaction(req_action) -> request {=
        lf_set_token(request, req_action->token);
    =}
    
    reaction(response) {=
        if (self->browser_ui.client_socket < 0) {
            lf_print_error("No pending request at the server!");
        }
        char *http_response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n";
        write(self->browser_ui.client_socket, http_response, strlen(http_response));
        write(self->browser_ui.client_socket, response->value, strlen(response->value));
        close(self->browser_ui.client_socket);
        self->browser_ui.client_socket = -1;
    =}
    
    reaction(shutdown) {=
        self->browser_ui.running = false;
        free(self->browser_ui.initial_page);
    =}
}

main reactor {
    state count:int = 0
    s = new ServerUI()
    
    reaction(s.request) -> s.response {=
        char* response;
        asprintf(&response, "You have pushed %d times. Path of GET request: %s", 
            ++self->count,
            s.request->value
        );
        lf_set(s.response, response);
    =}
}