/**
 * A basic user interface realized in the browser.
 * 
 * @author Edward A. Lee
 */
target C {
    keepalive: true
}
preamble {=
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <unistd.h>     // Defined read()
    
    typedef struct browser_ui_t {
        bool running;       // Indicator that listener thread is running.
        int client_socket;  // If non-negative, client socket awaiting response.
        void* req_action;   // The physical action triggered upon request.
    } browser_ui_t;
    
    // Initial web page
    char initial_page[] = "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n\r\n"
        "<!DOCTYPE html><html><head><title>Initial web page</title>"
        "</head><body>"
            "<h1>Browser UI for Lingua Franca</h1>"
            "<button id=\"append-button\">Press me!</button>"
            "<p id=\"content-container\"></p>"
        "<script>"
"  document.getElementById('content-container').innerHTML += 'NOTHING';"
"  document.getElementById('append-button').addEventListener('click', function() {"
"    var xhttp = new XMLHttpRequest();"
"    xhttp.onload = function() {"
"      if (this.status == 200) {"
"        var response = JSON.parse(this.responseText);"
"        var newContent = response.path;"
"        document.getElementById('content-container').innerHTML = newContent;"
"      } else {"
"        document.getElementById('content-container').innerHTML = \"Error: \" + this.statusText;"
"      }"
"    };"
"    xhttp.open('GET', '/request', true);"
"    xhttp.send(null);"
"  });" 
        "</script>"
        "</body></html>\r\n";
    
    void* listener_thread(void* args) {
        browser_ui_t* browser_ui = (browser_ui_t*)args;
        
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket < 0) {
            lf_print_error_and_exit("Error creating socket.");
        }

        int one = 1;
        // Allow reusing of local addresses.
        setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(int));

        struct sockaddr_in server_address;
        server_address.sin_family = AF_INET;
        server_address.sin_addr.s_addr = INADDR_ANY;
        server_address.sin_port = htons(8080);

        if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {
            close(server_socket);
            lf_print_error_and_exit("Error binding socket.");
        }
        // Pending queue length of 5.
        listen(server_socket, 5);
        
        lf_print("*** Point your browser to http://localhost:8080");

        while(browser_ui->running) {
            struct sockaddr_in client_address;
            int client_address_length = sizeof(client_address);
    
            browser_ui->client_socket = accept(server_socket, (struct sockaddr *)&client_address, (socklen_t*)&client_address_length);
    
            if (browser_ui->client_socket < 0) {
                lf_print_error_and_exit("Error accepting connection.");
            }

            char buffer[1024] = {0};
            read(browser_ui->client_socket, buffer, 1024);
            printf("Received request: %s\n", buffer);
    
            // The response depends on the path part of the request.
            const char *start_of_path = strchr(buffer, ' ') + 1;
            if (start_of_path != NULL && strncmp("/ ", start_of_path, 2) != 0) {
                const char *end_of_path = strchr(start_of_path, ' ') + 1;
                size_t length = end_of_path - start_of_path;
                char* path = (char*)malloc(length + 1);
                strncpy(path, start_of_path, length);
                path[length] = '\0';
                lf_schedule_value(browser_ui->req_action, 0, path, length + 1);
            } else {
                // Default is to write initial page.
                write(browser_ui->client_socket, initial_page, sizeof(initial_page));
                close(browser_ui->client_socket);
                browser_ui->client_socket = -1;
            }
        }
        return NULL;
    }
=}

reactor ServerUI {
    output request:char*
    input response:char*
    
    physical action req_action:char*
    
    state browser_ui:browser_ui_t
    
    reaction(startup) -> req_action {=
        self->browser_ui.running = true;
        self->browser_ui.client_socket = -1; // No client socket awaiting response.
        self->browser_ui.req_action = req_action;
        lf_thread_t listener;
        lf_thread_create(&listener, &listener_thread, &self->browser_ui);
    =}
    
    reaction(req_action) -> request {=
        lf_set_token(request, req_action->token);
    =}
    
    reaction(response) {=
        if (self->browser_ui.client_socket < 0) {
            lf_print_error("No pending request at the server!");
        }
        char *http_response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n";
        write(self->browser_ui.client_socket, http_response, strlen(http_response));
        write(self->browser_ui.client_socket, response->value, strlen(response->value));
        close(self->browser_ui.client_socket);
        self->browser_ui.client_socket = -1;
    =}
    
    reaction(shutdown) {=
        self->browser_ui.running = false;
    =}
}

main reactor {
    s = new ServerUI()
    
    reaction(s.request) -> s.response {=
        char* response = (char*)malloc(strlen(s.request->value + 13));
        sprintf(response, "{\"path\": \"%s\"}", s.request->value);
        lf_set(s.response, response);
    =}
}