/**
 * A web socket server enabling a user interface realized in the browser. This
 * creates a web server that listens on a port (default 8080) for web socket
 * connections. Compile and run this program, then open WebSocket.html in your
 * favorite browser.
 *
 * When a connection is established... FIXME FIXME: What about multiple
 * connections?
 *
 * This uses the <a href="https://libwebsockets.org">libwebsockets</a> (see <a
 * href="https://libwebsockets.org/lws-api-doc-main/html/index.html">API
 * documentation</a> and <a
 * href="https://libwebsockets.org/lws-api-doc-main/html/md_READMEs_README_build.html">installation
 * instructions</a>). To install on MacOS, we recommending using brew:
 * <pre> brew install libwebsockets
 * </pre> This puts the compiled libraries in {@code /usr/local/lib}, and these
 * libraries can be linked to providing the {@code -lwebsockets} compile option.
 * 
 * @author Edward A. Lee
 */
target C {
    keepalive: true,
    build-type: RelWithDebInfo,  // Release with debug info   FIXME
    cmake-include: ["WebSocketCmake.txt"]
}

import WebSocketServer from "WebSocketServer.lf"

preamble {=
    #include "hashset/hashset.h"  // For storing web socket instances that are connected.
=}

main reactor {
    state count: int = 0
    logical action send_action: web_socket_instance_t*
    
    state connected_instances: hashset_t = {= NULL =}

    s = new WebSocketServer(max_clients = 1)
    
    reaction(startup) -> s.send {=
        lf_set_destructor(s.send, web_socket_message_destructor);
        lf_set_copy_constructor(s.send, web_socket_message_copy_constructor);
        
        lf_print("======== Starting server. Open WebSocket.html in your favorite browser.");
        self->connected_instances = hashset_create(2); // Default capacity for four instances.
    =}

    reaction(s.connected) -> send_action {=
        lf_print("======== Connected %d", s.connected->value.connected);
        if (s.connected->value.connected) {
            // New connection.
            hashset_add(self->connected_instances, s.connected->value.wsi);
            
            // Start sending.
            // FIXME: Delay is required here. If we send right away, we get disconnected.
            lf_schedule_copy(send_action, SEC(1), &s.connected->value, 1);
        } else {
            // Disconnecting. Remove from hashset to prevent further scheduling.
            hashset_remove(self->connected_instances, s.connected->value.wsi);
        }
    =}

    reaction(s.received) {=
        // FIXME: Replace lf_print with LF_PRINT_LOG
        lf_print("======== Application received: %s", s.received->value->message);
    =}

    reaction(send_action) -> s.send, send_action {=
        // If the web socket is no longer connected, the instance will not be in the hashset.
        if (hashset_is_member(self->connected_instances, send_action->value->wsi)) {
            char* message;
            asprintf(&message, "Count is: %d", self->count++);
            
            web_socket_message_t* container = (web_socket_message_t*)malloc(sizeof(web_socket_message_t));
            container->message = message;
            container->length = strlen(message) + 1;
            container->wsi = send_action->value->wsi;
            
            lf_set(s.send, container);
            // Schedule the next send.
            lf_schedule_token(send_action, SEC(1), send_action->token);
        }
    =}
    
    reaction(shutdown) {=
        if (self->connected_instances != NULL) {
            hashset_destroy(self->connected_instances);
        }
    =}
}
