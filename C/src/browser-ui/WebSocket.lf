/**
 * A web socket server enabling a user interface realized in the browser. This
 * creates a web server that listens on a port (default 8080) for web socket
 * connections. Compile and run this program, then open WebSocket.html in your
 * favorite browser.
 *
 * When a connection is established... FIXME FIXME: What about multiple
 * connections?
 *
 * This uses the <a href="https://libwebsockets.org">libwebsockets</a> (see <a
 * href="https://libwebsockets.org/lws-api-doc-main/html/index.html">API
 * documentation</a> and <a
 * href="https://libwebsockets.org/lws-api-doc-main/html/md_READMEs_README_build.html">installation
 * instructions</a>). To install on MacOS, we recommending using brew:
 * <pre> brew install libwebsockets
 * </pre> This puts the compiled libraries in {@code /usr/local/lib}, and these
 * libraries can be linked to providing the {@code -lwebsockets} compile option.
 * 
 * @author Edward A. Lee
 */
target C {
    keepalive: true,
    build-type: RelWithDebInfo,  // Release with debug info
    cmake-include: ["WebSocketCmake.txt"]
}

// FIXME: Separate WebSocketServer into another file. Doesn't need hashset.

preamble {=
    #ifndef WEBSOCKET_H
    #define WEBSOCKET_H
    #include "util.h"       // Defines lf_print()
    #include "platform.h"   // Defines lf_thread_t, etc.
    #include "hashset/hashset.h"  // For storing web socket instances that are connected.

    #include <libwebsockets.h>

    typedef struct server_status_t {
        void* connected_action;       // Action to notify of changes in connected status.
        void* received_action;        // Action to notify of messages received.
        struct lws_context* context;  // The context.
        struct lws* wsi;       // Web socket instance. Only one instance allowed.
        bool running;          // Indicator that the listening thread is running.
        bool connected;        // Indicator that socket connection is open.
    } server_status_t;
    
    /**
     * Identifier for a web socket instance together with its connected state.
     * No need for a destructor or copy constructor here because the libwebsockets
     * code handles deallocating the wsi when the WS is closed.
     */
    typedef struct web_socket_instance_t {
        struct lws* wsi;       // Web socket instance.
        bool connected;
    } web_socket_instance_t;

    /**
     * A web socket string message together with its web socket instance.
     * This needs a destructor and copy constructor because the message
     * is assumed to be in allocated memory.
     */
    typedef struct web_socket_message_t {
        struct lws* wsi;       // Web socket instance.
        size_t length;
        char* message;
    } web_socket_message_t;
    
    /** Destructor for an instance of web_socket_message_t. */
    void web_socket_message_destructor(void* message);
    
    /** Copy constructor for an instance of web_socket_message_t. */
    void* web_socket_message_copy_constructor(void* message);
    
    #endif // WEBSOCKET_H
=}

/**
 * There are a number of limitations:
 * <ol>
 * <li> **FIXME:** This should use the secure sockets API in libwebsockets to get SSL.
 * <li> **FIXME:** Support binary data?
 * </ol>
 * 
 * @param hostport The host port number, which defults to 8000.
 */
reactor WebSocketServer(hostport: int = 8000) {
    output connected: web_socket_instance_t
    output received: web_socket_message_t*
    input send: web_socket_message_t*

    physical action connected_action: web_socket_instance_t
    physical action received_action: web_socket_message_t*

    state status: server_status_t

    preamble {=
        // Thread handling incoming messages.
        void* websocket_thread(void* args) {
            server_status_t* status = (server_status_t*)args;
            while(status->running) {
                // According to the docs, the timeout argument is ignored.
                lws_service(status->context, 50);
            }
            lws_context_destroy(status->context);
            return NULL;
        };

        // Callback handling HTTP requests.
        static int callback_http(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len) {
            bool result;
            server_status_t* status = (server_status_t*)lws_context_user(lws_get_context(wsi));
            if (status == NULL) {
                lf_print_error_and_exit("User struct NULL in callback!");
            }
            // FIXME: produce outputs.
            printf("HTTP callback invoked with reason: %d\n", reason);
            web_socket_instance_t ws_instance;
            switch(reason) {
                case LWS_CALLBACK_WSI_CREATE:
                    lf_print("**** Web socket connection requested.");
                    break;
                case LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED:
                    lf_print("**** Web socket new client.");
                    break;
                case LWS_CALLBACK_HTTP_CONFIRM_UPGRADE:
                    lf_print("**** Web socket connection established.");
                    // If we are already connected, refuse the new connection.
                    if (status->wsi != NULL) {
                        lf_print("**** Web socket connection refused.");
                        // Returning -1 hangs up the connection, according to lws-callbacks.h.
                        // Return +1 "if you have rejected the connection by returning http headers
                        // and response code yourself" (How to do that?)
                        return -1; // FIXME: This breaks the previous connection!
                    }
                    // FIXME: Next two fields not needed.
                    status->wsi = wsi;
                    status->connected = true;
                    
                    ws_instance.wsi = wsi;
                    ws_instance.connected = true;
                    
                    lf_schedule_copy(status->connected_action, 0, &ws_instance, 1);
                    break;
                case LWS_CALLBACK_WSI_DESTROY:
                    lf_print("**** Connection closed.");
                    // FIXME: Next two fields not needed.
                    status->wsi = NULL;
                    status->connected = false;
                    
                    ws_instance.wsi = wsi;
                    ws_instance.connected = false;
                    
                    status->running = false; // FIXME
                    lf_schedule_copy(status->connected_action, 0, &ws_instance, 1);
                    break;
                case LWS_CALLBACK_CLOSED:
                case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
                    lf_print_error("*** connection error.");
                    // FIXME: Next three fields not needed.
                    status->wsi = NULL;
                    status->connected = false;
                    status->running = false;

                    ws_instance.wsi = wsi;
                    ws_instance.connected = false;

                    lf_schedule_copy(status->connected_action, 0, &ws_instance, 1);
                    break;
                default:
                    break;
            }
            return 0;
        }

        // Callback handling web socket requests.
        static int callback_ws(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len) {
            printf("WS callback invoked with reason: %d\n", reason);
            server_status_t* status = (server_status_t*)lws_context_user(lws_get_context(wsi));
            if (status == NULL || status->wsi == NULL && reason != LWS_CALLBACK_EVENT_WAIT_CANCELLED) {
                // FIXME: LWS_CALLBACK_PROTOCOL_DESTROY reason seems to occur after closing. Why?
                lf_print_warning("**** No connection!");
                return -1;
            }
            switch(reason) {
                case LWS_CALLBACK_RECEIVE:
                    if (len > 0) {
                        lf_print("**** Server received WS message.");
                        
                        web_socket_message_t* received = (web_socket_message_t*)malloc(sizeof(web_socket_message_t));
                        received->wsi = wsi;
                        
                        // Message is not NULL terminated, so created a NULL-terminated version.
                        char* string = (char*)malloc((len + 1) * sizeof(char));
                        strncpy(string, (char*)in, len);
                        string[len] = 0;
                        received->length = len + 1;
                        received->message = string;
                        lf_schedule_value(status->received_action, 0, received, len + 1);
                    }
                    break;
                default:
                    break;
            }
            return 0;
        }
        
        void web_socket_message_destructor(void* message) {
            free(((web_socket_message_t*)message)->message);
            free(message);
        }
        
        void* web_socket_message_copy_constructor(void* message) {
            web_socket_message_t* cast = (web_socket_message_t*)message;
            web_socket_message_t* result = (web_socket_message_t*)malloc(sizeof(web_socket_message_t));
            size_t length = cast->length;
            char* copy = (char*)malloc(length * sizeof(char) + 1);
            result->message = strncpy(copy, cast->message, length);
            result->message[length] = 0;
            result->wsi = cast->wsi;
            return result;
        }
    =}

    reaction(startup) -> connected_action, received_action {=
        // The receiving thread dynamically allocates memory for messages.
        // Set the destructor and copy constructor.
        lf_set_destructor(received_action, web_socket_message_destructor);
        lf_set_copy_constructor(received_action, web_socket_message_copy_constructor);
        
        struct lws_context_creation_info info;
        memset(&info, 0, sizeof(info));
        info.port = self->hostport;
        info.iface = NULL; // FIXME: Can put a string here?
        info.protocols = (struct lws_protocols[]) {
          {
              "http",
              callback_http,
              0 // No per-session data.
          },
          {
              "ws",
              callback_ws,
              0 // No per-session data.
          },
          { NULL, NULL, 0 }
        };
        // To get callbacks to be passed a pointer to the status struct:
        info.user = &self->status;

        self->status.context = lws_create_context(&info);
        if (!self->status.context) {
          lf_print_error_and_exit("Failed to create server for web sockets.");
        }
        
        self->status.connected_action = connected_action;
        self->status.received_action = received_action;

        lf_thread_t listener;
        lf_thread_create(&listener, &websocket_thread, &self->status);
        self->status.running = true;
    =}
    
    reaction(connected_action) -> connected {=
        lf_set(connected, connected_action->value);
    =}

    reaction(received_action) -> received {=
        lf_set_token(received, received_action->token);
    =}

    reaction(send) {=
        int length = strlen(send->value->message);
        // The buffer needs LWS_PRE bytes _before_ the message.
        char buffer[LWS_PRE + length + 1];
        strcpy(buffer + LWS_PRE, send->value->message);
        int result = lws_write(send->value->wsi,(unsigned char*)(buffer + LWS_PRE), length + 1, LWS_WRITE_TEXT);
        if (result < length) {
            lf_print_warning("Send on web socket failed. Dropping message.");
        }
    =}

    reaction(shutdown) {=
        self->status.running = false;
     =}
}

main reactor {
    state count: int = 0
    state connected: bool = false
    logical action send_action: web_socket_instance_t*
    
    state connected_instances: hashset_t = {= NULL =}

    s = new WebSocketServer()
    
    reaction(startup) -> s.send {=
        lf_set_destructor(s.send, web_socket_message_destructor);
        lf_set_copy_constructor(s.send, web_socket_message_copy_constructor);
        
        lf_print("======== Starting server. Open WebSocket.html in your favorite browser.");
        self->connected_instances = hashset_create(2); // Default capacity for four instances.
    =}

    reaction(s.connected) -> send_action {=
        lf_print("======== Connected %d", s.connected->value.connected);
        if (s.connected->value.connected) {
            // New connection.
            hashset_add(self->connected_instances, s.connected->value.wsi);
            
            self->connected = true; // FIXME
            // Start sending.
            // FIXME: Delay is required here. If we send right away, we get disconnected.
            lf_schedule_copy(send_action, SEC(1), &s.connected->value, 1);
        } else {
            // Disconnecting.
            hashset_remove(self->connected_instances, s.connected->value.wsi);

            self->connected = false; // FIXME
            // Stop execution.
            lf_print("======= Connection closed. Exiting.");
            lf_request_stop();
        }
    =}

    reaction(s.received) {=
        lf_print("!!!!!!!!!!!!!!!!!!!! FIXME2 %zu", s.received->value->length);
        lf_print("======== Application received: %s", s.received->value->message);
    =}

    reaction(send_action) -> s.send, send_action {=
        if (hashset_is_member(self->connected_instances, send_action->value->wsi)) {
            char* message;
            asprintf(&message, "Count is: %d", self->count++);
            
            web_socket_message_t* container = (web_socket_message_t*)malloc(sizeof(web_socket_message_t));
            container->message = message;
            container->length = strlen(message) + 1;
            container->wsi = send_action->value->wsi;
            
            lf_set(s.send, container);
            // Schedule the next send.
            lf_schedule_token(send_action, SEC(1), send_action->token);
        }
    =}
    
    reaction(shutdown) {=
        if (self->connected_instances != NULL) {
            hashset_destroy(self->connected_instances);
        }
    =}
}
