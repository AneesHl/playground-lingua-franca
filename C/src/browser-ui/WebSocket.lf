/**
 * A web socket server enabling a user interface realized in the browser.
 * This creates a web server that listens on a port (default 8080)
 * for web socket connections. Compile and run this program, then open
 * WebSocket.html in your favorite browser.
 * 
 * When a connection is established... FIXME
 * FIXME: What about multiple connections?
 * 
 * 
 * This uses the <a href="https://libwebsockets.org">libwebsockets</a>
 * (see <a href="https://libwebsockets.org/lws-api-doc-main/html/index.html">API documentation</a>
 * and <a href="https://libwebsockets.org/lws-api-doc-main/html/md_READMEs_README_build.html">installation instructions</a>).
 * To install on MacOS, we recommending using brew:
 * <pre>
 *     brew install libwebsockets
 * </pre>
 * This puts the compiled libraries in {@code /usr/local/lib}, and these libraries
 * can be linked to providing the {@code -lwebsockets} compile option.
 * 
 * @author Edward A. Lee
 */
target C {
    keepalive: true,
    build-type: RelWithDebInfo, // Release with debug info
    cmake-include: ["WebSocketCmake.txt"]
}

preamble {=
    #ifndef WEBSOCKET_H
    #define WEBSOCKET_H
    #include "util.h"       // Defines lf_print()
    #include "platform.h"   // Defines lf_thread_t, etc.

    #include <libwebsockets.h>

    typedef struct websocket_t {
        struct lws_context* context;  // The context.
        struct lws* wsi;       // Web socket instance. FIXME: Assumes just one connection?
        bool running;          // Indicator that the listening thread is running.
        bool connected;        // Indicator that socket connection is open.
    } websocket_t;

    #endif // WEBSOCKET_H
=}

/**
 * FIXME
 * @param hostport The host port number, which defults to 8080.
 */
reactor WebSocketServer(
    hostport:int = 8000
) {
    output connected:bool
    output received:char*
    input send:char*
    
    physical action received_action:char*
    
    state context:websocket_t
    
    reaction(startup) -> received_action {=
      struct lws_context_creation_info info;
      memset(&info, 0, sizeof(info));
      info.port = self->hostport;
      info.iface = NULL; // FIXME: Can put a string here?
      info.protocols = (struct lws_protocols[]) {
        {
            "http",
            callback_http,
            0 // No per-session data.
        },
        {
            "ws",
            callback_ws,
            0 // No per-session data.
        },
        { NULL, NULL, 0 }
      };
      info.user = &self->context;

      self->context.context = lws_create_context(&info);
      if (!self->context.context) {
        lf_print_error_and_exit("Failed to create server for web sockets.");
      }

      lf_thread_t listener;
      lf_thread_create(&listener, &websocket_thread, &self->context);
      self->context.running = true;
    =}
    
    reaction(received_action) -> received, connected {=
        lf_print("Action triggered");
        /* FIXME
        if (strlen(req_action->value) == 0) {
            lf_set(initialized, true);
        } else {
            lf_set_token(request, req_action->token);
        }
        * 
        */
    =}
    
    reaction(send) {=
        if (!self->context.connected) {
            lf_print_warning("Web socket connection not open. Dropping message: %s", send->value);
        } else {
            // The buffer needs LWS_PRE bytes _before_ the message.
            char buffer[LWS_PRE + strlen(send->value) + 1];
            strcpy(buffer + LWS_PRE, send->value);
            int result = lws_write(self->context.wsi,(unsigned char*)(buffer + LWS_PRE), strlen(send->value) + 1, LWS_WRITE_TEXT); // FIXME: binary?
            if (result < 0) {
                lf_print_error("Send on web socket failed.");
                lf_request_stop();
            }
        }
    =}
    
    reaction(shutdown) {=
        self->context.running = false;
    =}

    preamble {=
        // Thread handling incoming messages.
        void* websocket_thread(void* args) {
            websocket_t* context = (websocket_t*)args;
            while(context->running) {
                // According to the docs, the timeout argument is ignored.
                lws_service(context->context, 50);
            }
            lws_context_destroy(context->context);
            return NULL;
        };
        
        // Callback handling HTTP requests.
        static int callback_http(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len) {
            websocket_t* context = (websocket_t*)lws_context_user(lws_get_context(wsi));
            if (context != NULL) {
                context->wsi = wsi; // FIXME: Just one connection?
            } else {
                lf_print_warning("User struct NULL in callback!");
            }
            // FIXME: produce outputs.
            printf("HTTP callback invoked with reason: %d\n", reason);
            switch(reason) {
                case LWS_CALLBACK_HTTP_CONFIRM_UPGRADE:
                    lf_print("**** Web socket connection established.");
                    context->connected = true;
                    break;
                case LWS_CALLBACK_WSI_DESTROY:
                    lf_print("**** Connection closed.");
                    context->connected = false;
                    context->running = false;
                    break;
                case LWS_CALLBACK_CLOSED:
                case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
                    lf_print_error("*** connection error.");
                    context->connected = false;
                    context->running = false;
                    break;
                default:
                    break;
            }
            return 0;
        }
        
        // Callback handling web socket requests.
        static int callback_ws(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len) {
            websocket_t* context = (websocket_t*)lws_context_user(lws_get_context(wsi));
            if (context != NULL) {
                context->wsi = wsi; // FIXME: Just one connection?
            } else {
                lf_print_warning("User struct null in callback!");
            }
            // FIXME: produce outputs.
          printf("Message length: %zu\n", len);
          if (len > 0) {
            char string[len + 1];
            strncpy(string, (char*)in, len);
            string[len] = 0;
            printf("Server received message: %s\n", string);
            
            // Send a message back
            // The buffer needs LWS_PRE bytes _before_ the message.
            char buffer[LWS_PRE + 6];
            strcpy(buffer + LWS_PRE, "Hello");
            lws_write(wsi,(unsigned char*)(buffer + LWS_PRE), 6, LWS_WRITE_TEXT);
          }
          return 0;
        }
    =}
}

main reactor {
    state count:int = 0
    timer t(1 s, 1 s)
    s = new WebSocketServer()
    
    reaction(s.connected) {=
        lf_print("Connected %d", s.connected->value);
    =}
    reaction(s.received) {=
        lf_print("Server received: %s", s.received->value);
    =}
    reaction(t) -> s.send {=
        char* message;
        asprintf(&message, "Count is: %d", self->count++);
        lf_set(s.send, message);
    =}
}
