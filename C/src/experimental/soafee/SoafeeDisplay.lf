target C {
    keepalive: true,
    cmake-include: [
        "curses.cmake",
    ] 
}
import ServerUI from "../../browser-ui/BrowserUI.lf"
import PlayWaveform from "../../rhythm/PlayWaveform.lf"

/**
 * Listen for user input. When the user hits a key,
 * then schedule a physical action to produce an output on key.
 * The startup is delayed to give the server a chance to print
 * its instruction message before curses takes over the terminal.
 */
reactor UserInput {
    preamble {=
        #include "platform.h"
        #include <curses.h>
        // Thread to read input characters until an EOF is received.
        // Each time a character is received, schedule a keypress action.
        void* read_input(void* keypress) {
            int c;
            while((c = getch()) != EOF) {
                if (c == 120 || c == 113) {
                    lf_request_stop();
                    break;
                }
                lf_schedule_copy(keypress, 0, &c, 1);
            }
            return NULL;
        }
        // Function to direct printed messages to the curses-managed terminal.
        void print_to_terminal(const char* format, va_list args) {
            move(8, 0);
            vwprintw(stdscr, format, args);
            refresh();
        }
    =}
    physical action keypress:int;
    
    timer start(1 s)
    
    output key:int;
    
    reaction(start) -> keypress {=
        initscr();  // Initialize the curses library
        cbreak();   // Disable line buffering
        noecho();   // Disable automatic echoing of typed characters
        keypad(stdscr, TRUE);  // Enable special keys
        
        move(0, 0);
        printw("Type q or x to exit.\n"
                "Point your browser to http://localhost:8080\n"
                "Type:\n"
                "   b to brake\n"
                "   UP to accelerate\n"
                "   DOWN to decelerate or reverse\n"
                "   r to reset\n");
        refresh();

        // Register a print function handler so lf_print works.
        lf_register_print_function(print_to_terminal, LOG_LEVEL_ALL);
        
        // Start the thread that listens for Enter or Return.
        lf_thread_t thread_id;
        lf_thread_create(&thread_id, &read_input, keypress);        
    =}
        
    reaction(keypress) -> key {=
        lf_set(key, keypress->value);
    =}
    reaction(shutdown) {=
        endwin();
        lf_register_print_function(NULL, -1);
    =}
}

/**
 * Emulator for automotive sensors. It outputs sensor data periodically
 * with the specified sample interval.
 * This reactor uses curses to listen
 * for keyboard entry and provides a simple test case where
 * pressing the up arrow increases the speed and pressing the
 * down arrow decrease the speed. To test the dashboard display,
 * this reactor assumes that the vehicle has an obstacle in front
 * of it at the specified initial front distance.
 */
reactor Sensors(
    sample_interval: time = 100 ms,
    initial_front_distance: int = 100   // In pixels
) {
    preamble {=
        #include <ncurses.h>
        #include <stdlib.h>    // Defines abs()
        #include <math.h>      // Defines lround()
    =}
    output speed: int          // In pixels/second
    output front_distance: int // In pixels
    
    state velocity: double = 0    // In pixels/second
    state position: double = 0    // In pixels
    
    timer t(0, sample_interval)
    
    u = new UserInput()
    
    reaction(u.key) {=
        if (u.key->value == KEY_UP) self->velocity++;
        else if (u.key->value == KEY_DOWN) self->velocity--;
        else if (u.key->value == 'b') self->velocity = 0;
        else if (u.key->value == 'r') {
            self->velocity = 0;
            self->position = 0.0;
        }
    =}
    
    reaction(t) -> speed, front_distance {=
        lf_set(speed, abs((int)lround(self->velocity)));

        // Update position.
        // Careful with rounding.
        self->position += self->velocity * (self->sample_interval / MSEC(1)) / 1000.0;
        
        lf_print("Position: %d\n", (int)lround(self->position));
        
        lf_set(front_distance, self->initial_front_distance - (int)lround(self->position));
    =}
}

reactor Dashboard {
    input speed:int
    input front_distance:int
    s = new ServerUI()

    reaction(s.request) speed, front_distance -> s.response {=
        char* response;
        asprintf(&response, "{\"front_distance\": %d, \"speed\": %d}", front_distance->value, speed->value);
        lf_set(s.response, response);
    =}
}

reactor SoundAlert {
    input front_distance:int
    logical action ding
    state ding_interval: time = 0  // 0 means no sound
    p = new PlayWaveform(default_waveform_id = 1)
    reaction(front_distance) -> ding {=
        instant_t previous_interval = self->ding_interval;
        // Change the period of the sound.
        if (front_distance->value > 75) {
            // Go silent.
            self->ding_interval = MSEC(0);
        } else if (front_distance->value > 50) {
            self->ding_interval = MSEC(2000);
        } else if (front_distance->value > 25) {
            self->ding_interval = MSEC(1000);
        } else if (front_distance->value > 15) {
            self->ding_interval = MSEC(500);
        } else {
            self->ding_interval = MSEC(200);
        }
        // If no sound is playing, start it playing.
        if (self->ding_interval > MSEC(0) && previous_interval == MSEC(0)) {
            lf_schedule(ding, 0);
        }
    =}
    reaction(ding) -> p.note, ding {=
        if (self->ding_interval > MSEC(0)) {
            lf_set(p.note, 1);
            lf_schedule(ding, self->ding_interval);
        }
    =}
}

main reactor {
    s = new Sensors()
    d = new Dashboard()
    a = new SoundAlert()
    s.speed -> d.speed
    s.front_distance -> d.front_distance
    s.front_distance -> a.front_distance
}