/**
 * This program models a redundant fault tolerant system where a primary node, if and when it fails,
 * is replaced by a backup node. The protocol is described in this paper:
 *
 * Bjarne Johansson; Mats RÃ¥gberger; Alessandro V. Papadopoulos; Thomas Nolte, "Consistency Before
 * Availability: Network Reference Point based Failure Detection for Controller Redundancy," paper
 * draft 8/15/23.
 *
 * @author Edward A. Lee
 * @author Marjan Sirjani
 */
target C

preamble {=
  enum message_type {
    heartbeat,
    pingNRP,
    pingNRP_response,
    request_new_NRP
  };
  typedef struct message_t {
    enum message_type type;
    int source;
    int destination;
  } message_t;
=}

reactor Node(
    id: int = 0,
    heartbeat_period: time = 1 s,
    max_missed_heartbeats: int = 2,
    fails_at_time: time = 0,     // For testing. 0 for no failure.
    // Time until ping is deemed to have failed.
    ping_timeout: time = 500 ms) {
  // There are two network interfaces:
  @side("east")
  input in1: message_t
  @side("east")
  input in2: message_t
  output out1: message_t
  output out2: message_t

  timer node_fails(fails_at_time)

  state heartbeats_missed_1: int = 0
  state heartbeats_missed_2: int = 0

  state NRP_network: int = 1
  state NRP_switch_id: int = 1

  state primary: int = 0  // The known primary node.

  state ping_pending: bool = false
  logical action ping_timed_out(ping_timeout)

  initial mode Waiting {
    reaction(startup) -> out1, out2 {=
      message_t ping_message;
      ping_message.type = pingNRP;
      ping_message.source = self->id;
      // NOTE: The paper does not specify how to select the initial NRP.
      // Here, we send with destination 0, which the switches interpret as first to respond.
      // First to respond will be id 1 at startup; then wait for a reply before
      // actually becoming the primary or backup.
      ping_message.destination = 0;
      lf_set(out1, ping_message);
    =}

    reaction(in1, in2) -> reset(Backup), reset(Primary) {=
      // Got a response to the ping from one or both switches.
      // NOTE: The paper calls for user intervention to select which is primary.
      // Here, we just choose id 1 to be primary.
      self->primary = 1;
      if (self->id == 1) {
        // Become primary.
        lf_set_mode(Primary);
        if (in1->is_present && in1->value.type == pingNRP_response) {
          lf_print("Primary node %d received ping response on network 1. Making switch %d the NRP.", self->id, in1->value.source);
          self->NRP_network = 1;
          self->NRP_switch_id = in1->value.source;
        } else if (in2->is_present && in2->value.type == pingNRP) {
          lf_print("Primary node %d received ping response on network 2. Making switch %d the NRP.", self->id, in2->value.source);
          self->NRP_network = 2;
          self->NRP_switch_id = in2->value.source;
        }
      } else {
        lf_set_mode(Backup);
      }
    =}
  }

  mode Backup {
    timer t(heartbeat_period, heartbeat_period)
    // FIXME: Need SENDIMHERETOPRIMARY with "longer interval"
    reaction(reset) {= lf_print("---- Node %d becomes backup.", self->id); =}

    reaction(node_fails) -> reset(Failed) {=
      if(lf_time_logical_elapsed() > 0LL) lf_set_mode(Failed);
    =}

    reaction(in1) {=
      if (in1->value.type == heartbeat) {
        lf_print("Backup node %d received heartbeat from node %d on network 1.", self->id, in1->value.source);
        self->heartbeats_missed_1 = 0;
      } else if (in1->value.type == pingNRP_response && in1->value.destination == self->id) {
        // Got a response from the NRP to a ping we sent after a partial timeout.
        lf_print("Backup node %d received ping response on network 1 from NRP on switch %d.", self->id, in1->value.source);
        // Don't do anything. Remain the backup.
      }
    =}

    reaction(in2) {=
      if (in2->value.type == heartbeat) {
        lf_print("Backup node %d received heartbeat from node %d on network 2.", self->id, in2->value.source);
        self->heartbeats_missed_2 = 0;
      } else if (in2->value.type == pingNRP_response && in2->value.destination == self->id) {
        // Got a response from the NRP to a ping we sent after a partial timeout.
        lf_print("Backup node %d received ping response on network 2 from NRP on switch %d.", self->id, in2->value.source);
        self->ping_pending = false;
        // Don't do anything. Remain the backup.
      }
    =}

    reaction(t) -> reset(Primary), out1, out2, ping_timed_out {=
      if (self->heartbeats_missed_1 > self->max_missed_heartbeats
          && self->heartbeats_missed_2 > self->max_missed_heartbeats) {
        // Simultaneous heartbeat misses. Assume the primary failed.
        lf_print("**** Backup node %d detects missing heartbeats on both networks.", self->id);
        lf_set_mode(Primary);
      } else if (self->heartbeats_missed_1 > self->max_missed_heartbeats
          || self->heartbeats_missed_2 > self->max_missed_heartbeats) {
        // Heartbeat missed on one network but not yet on the other.
        // Possible network failure.
        lf_print("**** Backup node %d detects missing heartbeats on one network.", self->id);
        // Ping the NRP.
        message_t message;
        message.source = self->id;
        message.type = pingNRP;
        message.destination = self->NRP_switch_id;
        if (self->NRP_network == 1) {
          lf_set(out1, message);
        } else {
          lf_set(out2, message);
        }
        lf_print("Backup node %d pings NRP on network %d, switch %d", self->id, self->NRP_network, self->NRP_switch_id);
        self->ping_pending = true;
        lf_schedule(ping_timed_out, 0);
      }
      // Increment the counters so if they are not reset to 0 by the next time,
      // we detect the missed heartbeat.
      self->heartbeats_missed_1++;
      self->heartbeats_missed_2++;
    =}

    reaction(ping_timed_out) -> out1, out2 {=
      if (self->ping_pending) {
        // Ping timed out.  Send request for new NRP on the other network.
        lf_print("Backup node %d gets no response from ping. Requesting new NRP.");
        message_t message;
        message.type = request_new_NRP;
        message.source = self->id;
        message.destination = self->primary;
        if (self->NRP_network == 1) {
          // Use network 2.
          lf_set(out2, message);
        } else {
          lf_set(out1, message);
        }
        self->ping_pending = false;
      }
    =}
  }

  mode Primary {
    timer heartbeat(0, heartbeat_period)
    reaction(reset) {= lf_print("---- Node %d becomes primary.", self->id); =}

    reaction(node_fails) -> reset(Failed) {=
      if(lf_time_logical_elapsed() > 0LL) lf_set_mode(Failed);
    =}

    reaction(heartbeat) -> out1, out2 {=
      lf_print("Primary node %d sends heartbeat on both networks.", self->id);
      message_t message;
      message.type = heartbeat;
      message.source = self->id;
      lf_set(out1, message);
      lf_set(out2, message);
    =}

    reaction(in1) {=
      if (in1->value.type == request_new_NRP) {
        // FIXME: Find a new candidate NRP on network 1.
        // FIXME: Confirm new NRP with backup.
      }
    =}

    reaction(in2) {=
      if (in2->value.type == request_new_NRP) {
        // FIXME: Find a new candidate NRP on network 1.
        // FIXME: Confirm new NRP with backup.
      }
    =}
  }

  mode Failed {
    reaction(reset) {=
      lf_print("#### Node %d fails.", self->id);
    =}
  }
}

/**
 * Switch with two interfaces. When a pingNRP message arrives on either interface, if the
 * destination matches the ID of this switch or the destination is 0, then the switch responds on
 * the same interface with a pingNRP_response message. When any other message arrives on either
 * interface, the switch forwards a copy of the message to the other interface. If any two messages
 * would be simultaneous on an output, one will be sent one microstep later.
 */
reactor Switch(
    id: int = 0,
    // For testing. 0 for no failure.
    fails_at_time: time = 0) {
  input in1: message_t
  @side("east")
  input in2: message_t
  @side("west")
  output out1: message_t
  output out2: message_t

  logical action pending_out1: message_t
  logical action pending_out2: message_t

  timer switch_fails(fails_at_time)

  initial mode Working {
    reaction(switch_fails) -> reset(Failed) {=
      if(lf_time_logical_elapsed() > 0LL) lf_set_mode(Failed);
    =}

    reaction(pending_out1) -> out1 {= lf_set(out1, pending_out1->value); =}

    reaction(pending_out2) -> out2 {= lf_set(out2, pending_out2->value); =}

    reaction(in1, in2) -> out1, out2, pending_out1, pending_out2 {=
      if (in1->is_present) {
        if (in1->value.type == pingNRP) {
          if (in1->value.destination == self->id || in1->value.destination == 0) {
            lf_print("==== Switch %d pinged by node %d. Responding.", self->id, in1->value.source);
            // Respond to the ping.
            message_t message;
            message.source = self->id;
            message.destination = in1->value.source;
            message.type = pingNRP_response;
            if (!out1->is_present) {
              lf_set(out1, message);
            } else {
              lf_schedule_copy(pending_out1, 0, &message, 1);
            }
          } else {
            // Forward the ping.
            if (!out2->is_present) {
              lf_set(out2, in1->value);
            } else {
              lf_schedule_copy(pending_out2, 0, &in1->value, 1);
            }
          }
        } else {
          // Forward the message.
          if (!out2->is_present) {
            lf_set(out2, in1->value);
          } else {
            lf_schedule_copy(pending_out2, 0, &in1->value, 1);
          }
        }
      }
      if (in2->is_present) {
        if (in2->value.type == pingNRP) {
          if (in2->value.destination == self->id) {
            lf_print("==== Switch %d pinged by node %d. Responding.", self->id, in2->value.source);
            // Construct a response to the ping.
            message_t message;
            message.source = self->id;
            message.destination = in2->value.source;
            message.type = pingNRP_response;
            // Respond to the ping if out2 is available.
            if (!out2->is_present) {
              lf_set(out2, message);
            } else {
              lf_schedule_copy(pending_out2, 0, &message, 1);
            }
          } else {
            // Forward the ping to out1 if out1 is available.
            if (!out1->is_present) {
              lf_set(out1, in2->value);
            } else {
              lf_schedule_copy(pending_out1, 0, &in2->value, 1);
            }
          }
        } else {
          // Forward the message if out1 is available.
          if (!out1->is_present) {
            lf_set(out1, in2->value);
          } else {
            lf_schedule_copy(pending_out1, 0, &in2->value, 1);
          }
        }
      }
    =}
  }

  mode Failed {
    reaction(reset) {= lf_print("==== Switch %d fails.", self->id); =}
  }
}

main reactor(heartbeat_period: time = 1 s, delay: time = 1 ms) {
  node1 = new Node(heartbeat_period=heartbeat_period, id=1, fails_at_time = 10 s)
  node2 = new Node(heartbeat_period=heartbeat_period, id=2, fails_at_time = 15 s)

  switch1 = new Switch(id=1, fails_at_time = 3 s)
  switch2 = new Switch(id=2)

  node1.out1 -> switch1.in1 after delay
  switch1.out1 -> node1.in1 after delay

  switch1.out2 -> switch2.in2 after delay
  switch2.out2 -> switch1.in2 after delay

  switch2.out1 -> node2.in1 after delay
  node2.out1 -> switch2.in1 after delay

  switch3 = new Switch(id=3)
  switch4 = new Switch(id=4)

  node1.out2 -> switch3.in1 after delay
  switch3.out1 -> node1.in2 after delay

  switch3.out2 -> switch4.in2 after delay
  switch4.out2 -> switch3.in2 after delay

  switch4.out1 -> node2.in2 after delay
  node2.out2 -> switch4.in1 after delay
}
